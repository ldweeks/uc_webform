<?php

/**********************************
 * Drupal Core Hook Functions
 **********************************/

/**
* Implementation of hook_perm().
*/
function lucas_perm() {
  return array('create registration_product', 'edit own registration_product');
} 

/**
* Implementation of hook_access().
*/
function lucas_access($op, $node, $account) {

  if ($op == 'create') {
    // Only users with permission to do so may create this node type.
    return user_access('create registration_product', $account);
  }

  // Users who create a node may edit or delete it later, assuming they have the
  // necessary permissions.
  if ($op == 'update' || $op == 'delete') {
    if (user_access('edit own registration_product', $account) && ($account->uid == $node->uid)) {
      return TRUE;
    }
  }
}

/**
* Implementation of hook_form().
*/
function lucas_form(&$node) {
  // The site admin can decide if this node type has a title and body, and how
  // the fields should be labeled. We need to load these settings so we can
  // build the node form correctly.
  $type = node_get_types('type', $node);

  if ($type->has_title) {
    $form['title'] = array(
      '#type' => 'textfield',
      '#title' => check_plain($type->title_label),
      '#required' => TRUE,
      '#default_value' => $node->title,
      '#weight' => -5
    );
  }

  if ($type->has_body) {
    // In Drupal 6, we can use node_body_field() to get the body and filter
    // elements. This replaces the old textarea + filter_form() method of
    // setting this up. It will also ensure the teaser splitter gets set up
    // properly.
    $form['body_field'] = node_body_field($node, $type->body_label, $type->min_word_count);
  }

  return $form;
}

/**
* Implementation of hook_enable().
*/
function lucas_enable() {

  // Here, I add the product class information directly into the database.
  db_query("INSERT INTO {uc_product_classes} (pcid, name, description) VALUES ('%s', '%s', '%s')", 'registration_product', 'Registration Product', 'A registration product allows store owners to sell registrations.');
  
  uc_product_add_default_image_field('registration_product');

  // These next two if statements are here to prevent the module from repeatedly 
  // adding these attributes when the module is enabled/disabled.
  $exists = db_result(db_query("SELECT name FROM {uc_attributes} WHERE name = '%s'", 'registration_key'));
  if (!($exists)) {
    db_query("INSERT INTO {uc_attributes} (name, label, ordering, required, display, description) VALUES ('%s', '%s', '%d', '%d', '%d', '%s')", 'registration_key', 'Registration Key', 0, 0, 0, 'A registration key for a registration form submission.');
  }

  $exists = db_result(db_query("SELECT name FROM {uc_attributes} WHERE name = '%s'", 'registration_form_id'));
  if (!($exists)) {
    db_query("INSERT INTO {uc_attributes} (name, label, ordering, required, display, description) VALUES ('%s', '%s', '%d', '%d', '%d', '%s')", 'registration_form_id', 'Registration Form ID', 0, 0, 0, 'A registration form ID for a registration form.');
  }
  
  // These two functions see the newly added product class, and then build up a product node-type for that class.
  node_types_rebuild();
  menu_rebuild();
}

/**
* Implementation of hook_disable().
* When the module is disabled, the registration product content type becomes a "regular" content type.
*/
function lucas_disable() {
  
  // I took most of this code from uc_product_class_delete_confirm_submit in uc_product.admin.inc
  $type = node_get_types('type', 'registration_product');
  $type->module = 'node';
  $type->custom = 1;
  node_type_save($type);

  db_query("DELETE FROM {uc_product_classes} WHERE pcid = '%s'", 'registration_product');
  module_invoke_all('product_class', 'registration_product', 'delete');
  uc_product_node_info(TRUE);
  node_types_rebuild();
  menu_rebuild();
  
  drupal_set_message(t('The Registration Product content type is no longer a product class.'));
}

/**********************************
 * Ubercart Hook Functions
 **********************************/

/**
* Implementation of hook_product_types().
*/
function lucas_product_types() {
  return array('registration_product');
}

/**********************************
 * Webform API Functions
 **********************************/

/**
 * Define callbacks that can be used as select list options.
 *
 * @return
 *   An array of callbacks that can be used for select list options. This array
 *   should be keyed by the "name" of the pre-defined list. The values should
 *   be an array with the following additional keys:
 *     - title: The translated title for this list.
 *     - options callback: The name of the function that will return the list.
 *     - file: Optional. The file containing the options callback, relative to
 *       the module root.
 */
function lucas_webform_select_options_info() {
  $items = array();

  $items['registration_products'] = array(
    'title' => t('Registration Products'),
    'options callback' => 'ldw_options_products',
  );

  return $items;
}

/**
 * Option list containing the days of the week.
 */
function ldw_options_products() {
  
  $products = array();
  
  // http://api.ubercart.org/api/function/uc_product_types/2
  $types = uc_product_types();
  
  $result = db_query("SELECT nid, title FROM {node} WHERE type IN (". db_placeholders($types, 'varchar') .") " ."ORDER BY title", $types);
  
  while ($row = db_fetch_object($result)) {
    $products[$row->nid] = t("$row->title");
  }
  
/*  $products = array(
    'sunday' => t('Sunday'),
    'monday' => t('Monday'),
    'tuesday' => t('Tuesday'),
    'wednesday' => t('Wednesday'),
    'thursday' => t('Thursday'),
    'friday' => t('Friday'),
    'saturday' => t('Saturday'),
  );*/

  return $products;
}


/**
 * Define components to Webform.
 *
 * @return
 *   An array of components, keyed by machine name. Required properties are
 *   "label" and "description". The "features" array defines which capabilities
 *   the component has, such as being displayed in e-mails or csv downloads.
 *   A component like "markup" for example would not show in these locations.
 *   The possible features of a component include:
 *
 *     - csv
 *     - email
 *     - email_address
 *     - email_name
 *     - required
 *     - conditional
 *     - spam_analysis
 *     - group
 *
 *   Note that these features do not indicate the default state, but determine
 *   if the component can have this property at all. Setting "required" to TRUE
 *   does not mean that a field will always be required, but instead give the
 *   option to the administrator to choose the requiredness. See the example
 *   implementation for details on how these features may be set.
 *
 *   An optional "file" may be specified to be loaded when the component is
 *   needed. A set of callbacks will be established based on the name of the
 *   component. All components follow the pattern:
 *
 *   _webform_[callback]_[component]
 *
 *   Where [component] is the name of the key of the component and [callback] is
 *   any of the following:
 *
 *     - defaults
 *     - theme
 *     - edit
 *     - delete
 *     - render
 *     - display
 *     - analysis
 *     - table
 *     - csv_headers
 *     - csv_data
 *
 * See the sample component implementation for details on each one of these
 * callbacks.
 */
 
function lucas_webform_component_info() {
  $components = array();

  $components['uc_product'] = array(
    'label' => t('Ubercart Product'),
    'description' => t('Add Ubercart Products to your webform.'),
    'features' => array(
      // Add content to CSV downloads. Defaults to TRUE.
      'csv' => TRUE,
      // Show this field in e-mailed submissions. Defaults to TRUE.
      'email' => TRUE,
      // This field may be toggled as required or not. Defaults to TRUE.
      'required' => TRUE,
    )
  );

  //dpm($components, "Components");
  
  return $components;
}

/**
 * Alter the list of available Webform components.
 *
 * @param $components
 *   A list of existing components as defined by hook_webform_component_info().
 *
 * @see hook_webform_component_info()
 */
/*function lucas_webform_component_info_alter(&$components) {
  dpm($components, "Components Before");
  
  $components['uc_product'] = array(
    'label' => t('Ubercart Product'),
    'description' => t('Add Ubercart Products to your webform.'),
    'features' => array(
      // Add content to CSV downloads. Defaults to TRUE.
      'csv' => TRUE,
      // Show this field in e-mailed submissions. Defaults to TRUE.
      'email' => TRUE,
      // This field may be toggled as required or not. Defaults to TRUE.
      'required' => TRUE,
    )
  );
  dpm($components, "Components After");
}*/


/**
 * Specify the default properties of a component.
 *
 * @return
 *   An array defining the default structure of a component.
 */
function _webform_defaults_uc_product() {
  return array(
    'name' => '',
    'form_key' => NULL,
    'email' => 1,
    'mandatory' => 0,
    'pid' => 0,
    'weight' => 0,
    'extra' => array(
      'description' => '',
    ),
  );
}

/**
 * Generate the form for editing a component.
 *
 * Create a set of form elements to be displayed on the form for editing this
 * component. Use care naming the form items, as this correlates directly to the
 * database schema. The component "Name" and "Description" fields are added to
 * every component type and are not necessary to specify here (although they
 * may be overridden if desired).
 *
 * @param $component
 *   A Webform component array.
 * @return
 *   An array of form items to be displayed on the edit component page
 */
function _webform_edit_uc_product($component) {
  $form = array();

  // Disabling the description if not wanted.
  $form['description'] = array();
  
  // http://api.ubercart.org/api/function/uc_product_types/2
  $types = uc_product_types();
  
  $result = db_query("SELECT nid, title FROM {node} WHERE type IN (". db_placeholders($types, 'varchar') .") " ."ORDER BY title", $types);
  
  while ($row = db_fetch_object($result)) {
    $products[$row->nid] = $row->title;
  }
  
  // Most options are stored in the "extra" array, which stores any settings
  // unique to a particular component type.
  $form['extra']['products'] = array(
    '#type' => 'select',
    '#title' => t('Products'),
    '#default_value' => $component['extra']['products'],
    '#multiple' => TRUE,
    '#description' => t('Please select your products.'),
    '#weight' => -3,
    '#size' => 20,
    '#required' => TRUE,
    '#options' => $products,
  );
  $form['extra']['multiple'] = array(
    '#type' => 'checkbox',
    '#title' => t('Multiple'),
    '#default_value' => $component['extra']['products'],
    '#description' => t('Check this option if the user is allowed to select multiple products.'),
    '#weight' => -2,
  );
  
  return $form;
}

/**
 * Render a Webform component to be part of a form.
 *
 * @param $component
 *   A Webform component array.
 * @param $value
 *   If editing an existing submission or resuming a draft, this will contain
 *   an array of values to be shown instead of the default in the component
 *   configuration. This value will always be an array, keyed numerically for
 *   each value saved in this field.
 */
function _webform_render_uc_product($component, $value = NULL) {

  $products = array();
  
  foreach($component['extra']['products'] as $val) {
    // I'm using the key here because I set it up originally to be 'nid => title', even though it currently is 'nid => nid'. I'm still not sure why the title never makes it to the database.
    $node = node_load($val);
    
    //<div class="webform-component-' . $component['type'] . '-price" id=webform-component-'. $component['form_key'] . '-price">
    $product_title = '<span>' . t("$node->title") . ', Price: $' . round($node->sell_price, 2) . '</span>';
    $products[$node->nid] = t($product_title);
  }
  
  if ($component['extra']['multiple'] == 0) {
    $form_item = array(
      '#type' => 'radios',
      '#title' => $component['name'],
      '#weight' => $component['weight'],
      '#description'   => _webform_filter_descriptions($component['extra']['description']),
      '#prefix' => '<div class="webform-component-'. $component['type'] .'" id="webform-component-'. $component['form_key'] .'">',
      '#suffix' => '</div>',
      '#options' => $products,
    );
  }
  elseif ($component['extra']['multiple'] == 1) {
    $form_item = array(
      '#type' => 'checkboxes',
      '#title' => $component['name'],
      '#weight' => $component['weight'],
      '#description'   => _webform_filter_descriptions($component['extra']['description']),
      '#prefix' => '<div class="webform-component-'. $component['type'] .'" id="webform-component-'. $component['form_key'] .'">',
      '#suffix' => '</div>',
      '#options' => $products,
    );
  }  
  
  if (isset($value)) {
    $form_item['#default_value'] = $value;
  }
    
  return $form_item;
}

/**
 * Display the result of a submission for a component.
 * 
 * The output of this function will be displayed under the "Results" tab then
 * "Submissions". This should output the saved data in some reasonable manner.
 *
 * @param $component
 *   A Webform component array.
 * @param $value
 *   An array of information containing the submission result, directly
 *   correlating to the webform_submitted_data database table schema.
 * @param $format
 *   Either 'html' or 'text'. Defines the format that the content should be
 *   returned as. Make sure that returned content is run through check_plain()
 *   or other filtering functions when returning HTML.
 * @return
 *   A renderable element containing at the very least these properties:
 *    - #title
 *    - #weight
 *    - #component
 *    - #format
 *    - #value
 *   Webform also uses #theme_wrappers to output the end result to the user,
 *   which will properly format the label and content for use within an e-mail
 *   (such as wrapping the text) or as HTML (ensuring consistent output).
 */
function _webform_display_uc_product($component, $value, $format = 'html') {

  $products = array();
  
  if (isset($value)) {
    foreach($value as $product) {
      if($product != 0) {
        $node = node_load($product);
        
        $product_title = t("$node->title") . ', Price: $' . round($node->sell_price, 2);
        array_push($products, t($product_title));
      }
    }
  }
  
  return array(
    '#title' => $component['name'],
    '#weight' => $component['weight'],
    '#theme' => 'webform_display_uc_product',
    '#theme_wrappers' => $format == 'html' ? array('webform_element') : array('webform_element_text'),
    '#post_render' => array('webform_element_wrapper'),
    '#component' => $component,
    '#format' => $format,
    '#value' => $products,
  );
}

/**
 * Module specific instance of hook_theme().
 *
 * This allows each Webform component to add information into hook_theme().
 */
function _webform_theme_uc_product() {
  return array(
    'webform_display_uc_product' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * Format the text output for the uc_product component.
 */
function theme_webform_display_uc_product($element) {
  
  // I may need to rethink this in the future.
  if (isset($element['#value'])) {
    $output = theme('item_list', $element['#value']);
  }

  return $output;
}

/**
 * Respond to a Webform submission being inserted.
 *
 * Note that this hook is called after a submission has already been saved to
 * the database. If needing to modify the submission prior to insertion, use
 * hook_webform_submission_presave().
 *
 * @param $node
 *   The Webform node on which this submission was made.
 * @param $submission
 *   The Webform submission that was just inserted into the database.
 */
function lucas_webform_submission_insert($node, $submission) {
  
  dpm($node, 'Node');
  dpm($submission, 'Submission');
  
  $components = $node->webform['components'];  
  $component_ids = array();
  $hello = "hello!";
  
  foreach ($components as $component) {
    if ($component['type'] == 'uc_product') {
      if (array_key_exists($component['cid'], $submission->data)) {
        $key = $component['cid'];
        foreach ($submission->data[$key]['value'] as $product) {
          if($product != 0) {
            /*$registration_key = date('YmdHis') . '-' . preg_replace("/[^a-zA-Z]/", "", $lastname);
            $data = array('attributes' => array(4 => $registration_key, 3 => $webform_id));
            uc_cart_add_item($product, 1, $data); //UC API call*/
          }
        }
      }
    }
  }
}